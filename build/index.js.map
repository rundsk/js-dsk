{
  "version": 3,
  "sources": ["pnp:/Users/mariuswilms/Code/dsk/js-sdk/src/Client.js", "pnp:/Users/mariuswilms/Code/dsk/js-sdk/src/Doc.js", "pnp:/Users/mariuswilms/Code/dsk/js-sdk/src/Tree.js"],
  "sourcesContent": ["/**\n * Copyright 2020 Marius Wilms, Christoph Labacher. All rights reserved.\n * Copyright 2017 Atelier Disko. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n// Client for accessing the DSK APIv2.\n//\n// The client supports versions, you can select the version on a per\n// API call basis. If a version is not specified, the primary version\n// is being used.\n\nlet cancelSearch = null;\nlet cancelFilter = null;\n\nexport default class Client {\n  static hello() {\n    return this.fetch('/api/v2/hello');\n  }\n\n  static config() {\n    return this.fetch('/api/v2/config');\n  }\n\n  static sources() {\n    return this.fetch('/api/v2/sources');\n  }\n\n  // Returns a WebSocket connection to the messages endpoint. Asummes it\n  // is reachable over TLS, when we have been loaded using it.\n  static messages() {\n    let protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n    let host = window.location.hostname;\n    let port = window.location.port ? `:${window.location.port}` : '';\n\n    return new WebSocket(`${protocol}://${host}${port}/api/v2/messages`);\n  }\n\n  static tree(version = null) {\n    let params = new URLSearchParams();\n    if (version) {\n      params.set('v', version);\n    }\n\n    return this.fetch(`/api/v2/tree?${params.toString()}`);\n  }\n\n  // Check if a node is present. Returns a promise that resolves to a boolean\n  // indicating whether a node exists under the given URL.\n  static has(url, version = null) {\n    let params = new URLSearchParams();\n    if (version) {\n      params.set('v', version);\n    }\n\n    return this.ping(`/api/v2/tree/${this.url(url)}?${params.toString()}`);\n  }\n\n  // Returns node for given relative URL path.\n  static get(url, version = null) {\n    let params = new URLSearchParams();\n    if (version) {\n      params.set('v', version);\n    }\n\n    return this.fetch(`/api/v2/tree/${this.url(url)}?${params.toString()}`);\n  }\n\n  // Returns a promise that resolve with the URL to a playground's index.html,\n  // which can be used as the source for an iframe.\n  static playgroundURL(node, doc, component, version = null) {\n    let params = new URLSearchParams();\n    if (version) {\n      params.set('v', version);\n    }\n\n    return Promise.resolve(\n      `/api/v2/tree/${this.url(node)}/_docs/${doc}/_playgrounds/${component}/index.html?${params.toString()}`\n    );\n  }\n\n  // Will automatically strip leading and trailing slashes from the given\n  // URL to turn it into a valid (node) URL for lookup.\n  static url(url) {\n    if (url?.charAt(0) === '/') {\n      url = url.substring(1);\n    }\n    if (url?.charAt(url.length - 1) === '/') {\n      url = url.slice(0, -1);\n    }\n    return url;\n  }\n\n  // Performs a full text search against the tree and returns the response\n  // unfiltered.\n  static search(q, version = null) {\n    let params = new URLSearchParams();\n    params.set('q', q);\n    if (version) {\n      params.set('v', version);\n    }\n\n    if (cancelSearch) {\n      cancelSearch();\n    }\n\n    let [promise, cancel] = this.fetchWithCancellation(`/api/v2/search?${params.toString()}`);\n    cancelSearch = cancel;\n    return promise;\n  }\n\n  // Performs a narrow search against the tree. The returned nodes together\n  // with `Tree.filteredBy()` can be used to create a new filtered tree view:\n  //\n  // ```\n  // Client.filter('foo')\n  //   .then((res) => {\n  //      return res.nodes.map(n => n.url);\n  //   })\n  //   .then((urls) => {\n  //      return Tree.filteredBy(urls);\n  //   });\n  // ```\n  static filter(q, version = null) {\n    let params = new URLSearchParams();\n    params.set('q', q);\n    if (version) {\n      params.set('v', version);\n    }\n\n    if (cancelFilter) {\n      cancelFilter();\n    }\n\n    let [promise, cancel] = this.fetchWithCancellation(`/api/v2/filter?${params.toString()}`);\n    cancelFilter = cancel;\n\n    return promise;\n  }\n\n  // Performs HTTP GET requests, returns a promise. Fail promise when there\n  // is a network issue (catch) as well as when we a HTTP response status\n  // indicating an error. Using plain XHR for better browser support and easier\n  // basic auth handling.\n  static fetch(url, type = 'json') {\n    let [promise] = this.fetchWithCancellation(url, type);\n    return promise;\n  }\n\n  // Advanced version of Client.fetch which supports cancellation.\n  static fetchWithCancellation(url, type = 'json') {\n    return this._fetch(url, type);\n  }\n\n  static _fetch(url, type = 'json') {\n    let cancel;\n    let promise = new Promise((resolve, reject) => {\n      let xhr = new XMLHttpRequest();\n      xhr.responseType = type;\n\n      cancel = () => {\n        reject('Request was cancelled');\n        xhr.abort();\n      };\n\n      xhr.addEventListener('readystatechange', () => {\n        if (xhr.readyState === 4) {\n          let first = xhr.status.toString().charAt(0);\n\n          if (first !== '2' && first !== '3') {\n            // The JSON error responses are formatted according to\n            // JSend, and carry an error message in the `message`\n            // property.\n            if (type === 'json') {\n              try {\n                reject(new Error(`Fetching '${url}' failed :-S: ${xhr.response.message}`));\n              } catch (e) {\n                reject(new Error(`Fetching '${url}' failed :-S: ${xhr.statusText}`));\n              }\n            } else {\n              reject(new Error(`Fetching '${url}' failed :-S: ${xhr.statusText}`));\n            }\n            return;\n          }\n          resolve(xhr.response);\n        }\n      });\n      xhr.addEventListener('error', (ev) => {\n        reject(new Error(`Fetching '${url}' failed :-S: ${ev}`));\n      });\n      xhr.open('GET', url);\n      xhr.setRequestHeader('Accept', type === 'json' ? 'application/json' : '*/*');\n      xhr.send();\n    });\n\n    return [promise, cancel];\n  }\n\n  // Performs HTTP HEAD requests, returns a promise that resolves to a\n  // boolean, indicating whether the resource under the given URL is existent.\n  static ping(url) {\n    return new Promise((resolve, reject) => {\n      let xhr = new XMLHttpRequest();\n\n      xhr.addEventListener('readystatechange', () => {\n        if (xhr.readyState === 4) {\n          let first = xhr.status.toString().charAt(0);\n\n          if (first !== '2' && first !== '3' && first !== '4') {\n            reject(new Error(`Pinging '${url}' failed :-S: ${xhr.statusText}`));\n          } else {\n            resolve(first === '2' || first === '3');\n          }\n        }\n      });\n      xhr.addEventListener('error', (ev) => {\n        reject(new Error(`Pinging '${url}' failed :-S: ${ev}`));\n      });\n      xhr.open('HEAD', url);\n      xhr.send();\n    });\n  }\n}\n", "/**\n * Copyright 2020 Marius Wilms, Christoph Labacher. All rights reserved.\n * Copyright 2017 Atelier Disko. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nexport default class DocTransformer {\n  // Constructor.\n  //\n  // Available options are:\n  // - `isPreformatted`, a function that receives the node type and must return\n  //   a boolen which indicates that the children of the node are preformatted.\n  //\n  //   ```\n  //   new Doc(..., ..., ..., {\n  //     isPreformatted: type => type === 'pre'\n  //   });\n  //   ```\n  //\n  // - `noTransform`, a function that receives the type and props and\n  //   must return a DOM node. The function is called whenever there is no\n  //   transformation found for a node.\n  //\n  //   The following code turns a node into a React element, which is necessary\n  //   because the parent might be a React element, which can\u2019t have regular DOM\n  //   nodes in props.children.\n  //\n  //   ```\n  //   new Doc(..., ..., ..., {\n  //     noTransform: function(type, props) {\n  //       return React.createElement(type, props, props.children);\n  //     }\n  //   });\n  //   ```\n  constructor(html, transforms = {}, orphans = [], options = {}) {\n    this.html = html;\n\n    // Turn all the keys of our transforms into lowercase, because that\u2019s how\n    // HTML is parsed.\n    this.transforms = {};\n\n    let key;\n    let keys = Object.keys(transforms);\n\n    let n = keys.length;\n    while (n--) {\n      key = keys[n];\n      this.transforms[key.toLowerCase()] = transforms[key];\n    }\n\n    this.orphans = orphans;\n\n    let defaults = {\n      isPreformatted: type => type === 'pre',\n      noTransform: (/* type, props */) => null,\n    };\n    this.options = Object.assign({}, defaults, options);\n  }\n\n  compile() {\n    let start = performance.now();\n\n    // Use the browsers machinery to parse HTML and allow us to iterate\n    // over it easily. Later child nodes are unwrapped from body again.\n    let body = document.createElement('body');\n    body.innerHTML = this.html;\n\n    body.innerHTML = this.orphan(body);\n    this.clean(body);\n\n    let children = [];\n    body.childNodes.forEach(c => {\n      let t = this.transform(c);\n      if (t) {\n        children.push(t);\n      }\n    });\n\n    console.log(`Document compilation with ${children.length} node/s took ${performance.now() - start}ms`);\n    return children;\n  }\n\n  // Sometimes children are unnecessarily wrapped into another element.\n  // If we find such elements, we unwrap them from their parent.\n  //\n  // This modifies the tree above the current node. Thus breaks our\n  // tree walk and must be executed in a separate step.\n  orphan(root) {\n    if (!this.orphans) {\n      return root.innerHTML;\n    }\n\n    let orphans = root.querySelectorAll(this.orphans.join(','));\n\n    orphans.forEach(c => {\n      console.log(`Unwrapping ${c} from ${c.parentNode}`);\n\n      // > If the given child is a reference to an existing node in the\n      //   document, insertBefore() moves it from its current position to the new\n      //   position (there is no requirement to remove the node from its parent\n      //   node before appending it to some other node).\n      //   - https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n      c.parentNode.parentNode.insertBefore(c, c.parentNode);\n    });\n    return root.innerHTML;\n  }\n\n  // Removes any elements, that may have become empty due to other\n  // processing steps.\n  clean(root) {\n    root.querySelectorAll('p:empty').forEach(el => {\n      el.remove();\n    });\n  }\n\n  // Replaces a given DOM node by applying a \"transform\".\n  transform(node) {\n    // Ignore nodes that only contain whitespace.\n    if (node.nodeType === Node.TEXT_NODE && !node.nodeValue.trim()) {\n      // Allow single spaces, for example between inline-elements\n      if (node.nodeValue !== ' ') {\n        return null;\n      }\n    }\n    if (!node.tagName) {\n      return node.textContent;\n    }\n    let type = node.tagName.toLowerCase();\n    let props = { children: [] };\n\n    let apply = this.transforms[type];\n\n    // Turn node attributes into props object.\n    for (let i = 0; i < node.attributes.length; i++) {\n      props[node.attributes[i].name] = node.attributes[i].value;\n    }\n\n    // Do not descend and transform children, when the node is considered to\n    // have preformatted contents.\n    if (this.options.isPreformatted(type)) {\n      props.children = node.innerHTML;\n    } else {\n      node.childNodes.forEach(c => {\n        let t = this.transform(c);\n        if (t) {\n          props.children.push(t);\n        }\n      });\n\n      // If the node has no children, insert the text content as children.\n      if (!props.children.length) {\n        props.children = node.textContent || undefined;\n      }\n    }\n\n    // If the node has no key, we create a random one.\n    if (!props.key) {\n      props.key = Math.random();\n    }\n\n    // If there is no transform for the node, ignore it but still do include the\n    // node in the final result.\n    if (!apply) {\n      if (this.options.noTransform) {\n        return this.options.noTransform(type, props);\n      }\n      console.log(`No transform to apply to ${type}`);\n      // FIXME: Children may be transformable; don't stop here.\n    }\n\n    return apply(props);\n  }\n}\n\nexport function transform(html, transforms = {}, orphans = [], options = {}) {\n  return new DocTransformer(html, transforms, orphans, options).compile();\n}\n", "/**\n * Copyright 2020 Marius Wilms, Christoph Labacher. All rights reserved.\n * Copyright 2017 Atelier Disko. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nimport Client from './Client.js';\n\n// Tree data structure for working with responses from the dsk API.\n//\n// https://en.wikipedia.org/wiki/Tree_traversal\nexport default class Tree {\n  constructor(root) {\n    this.root = root;\n  }\n\n  // One way sync: updates the data from backend source.\n  sync() {\n    return Client.tree().then(data => {\n      this.root = data.root;\n    });\n  }\n\n  // Returns a flat list of all nodes in the tree. The \"node\" parameter is for\n  // rescursive invocation and should be null when called initally.\n  flatten(node = null) {\n    let list = [];\n\n    ((node || this.root).children || []).each(child => {\n      list.push(child);\n      list = list.concat(this.flatten(child));\n    });\n    return list;\n  }\n\n  // Returns a new non-sparse tree instance selecting only given\n  // nodes, their parents and all their children.\n  //\n  // Filters out any not selected nodes. Descends into branches first,\n  // then works its way back up the tree filtering out any nodes, that\n  // are not selected. For selection conditions see check().\n  //\n  // Selecting a leaf node, selects all parents. But not the siblings.\n  //\n  //           a*\n  //\n  //           b*\n  //\n  //      c!   d   e\n  //\n  // Selecting a node, always selects all its children.\n  //\n  //           a*\n  //\n  //           b!\n  //\n  //      c*   d*   e*\n  //\n  filteredBy(selectedURLs = []) {\n    let tree = new Tree(JSON.parse(JSON.stringify(this.root))); // deep clone\n\n    if (selectedURLs) {\n      let check = n => selectedURLs.includes(n.url) || n.children.some(check);\n\n      let select = n => {\n        if (selectedURLs.includes(n.url)) {\n          return true;\n        }\n\n        n.children = n.children.filter(select);\n        return n.children.some(check);\n      };\n      tree.root.children = tree.root.children.filter(select);\n    }\n\n    return tree;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
